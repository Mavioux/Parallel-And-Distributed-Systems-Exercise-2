# Parallel-And-Distributed-Systems-Exercise-2

## Ανάλυση αλγορίθμου V0

Η σειριακή αναζήτηση των kκοντινότερων γειτόνων απαιτούσε την απλή εφαρμογή του τύπου που δινόταν. Μέσω της συνάρτησης cblas_dgemmέγινε ο πολλαπλασιασμός των X, Yκαι με απλές επαναλήψεις στα περιεχόμενα των X, Yυπολογίστηκε ο τελικός πίνακας D. Στη συνέχεια, εξίσου σημαντικός ήταν και ο κώδικας αναζήτησης των kκοντινότερων γειτόνων με αναζήτηση στον πίνακα Dκαι θέτοντας ίσες με άπειρο τις τιμές που ήδη επιλέχθηκαν. Με τον τρόπο αυτόν επιστρέφεται το τελικό knnresultstructμε τους πίνακες των κοντινότερων γειτόνων και κοντινότερων αποστάσεων για κάθε στοιχείο του Yμε βάση τον αρχικό πίνακα X.

## Ανάλυση αλγορίθμου V1

Σε αυτήν την έκδοση του αλγορίθμου ο υπολογισμός του τελικού knnresultγινόταν συγχρόνως με χρήση πολλών επεξεργαστών, διαμοιράζοντας ουσιαστικά το πρόβλημα σε pυποπροβλήματα. Αρχικά, ο πίνακας των Xήταν γνωστός μόνο στο μηδενικό επεξεργαστήκαι διαμοίραζευποπίνακες του Χ σε κάθε επεξεργαστή.Αυτό επετεύχθημέσω ενός forloopπου διαμοίραζε το κατάλληλο σημείο (Pointer) του αρχικού πίνακα και το εύρος τιμών, προκειμένου ο κάθε επεξεργαστής να γνωρίζει τα στοιχεία του αρχικού προβλήματος τα οποία του αναλογούν, μέσω των εντολών MPI_Sendκαι MPI_Recv.Στη συνέχεια, θεωρήθηκε αποδοτικότερη η διαμοίραση,μέσω μιας δομής δαχτυλιδιού,των υποπινάκων μεταξύ των επεξεργαστών, προκειμένου να γίνεται η αναζήτηση των kκοντινότερων γειτόνων (μέσω της προηγούμενη συνάρτησης knnτου v0)και στο τέλος κάθε επεξεργαστής να έχει υπολογίσει το δικό του knnresultγια τον αρχικό του υποπίνακα. Δηλαδή γινόταν διαμοιρασμός των πινάκων που θεωρούνται ως Χ  ενώ το Yήταν πάντα σταθερό για κάθε διεργασία.Μόλις τελείωνε αυτή η διαδικασία γινόταν εκπομπή του κάθε υποπίνακα στην αρχική διεργασία προκειμένου να συγκεντρωθεί το αποτέλεσμα ολοκληρωμένο.

## Ανάλυση αλγορίθμου V2

Σε συνέχεια της προηγούμενης διαδικασίας και σύμφωνα με την εξαιρετική ιδέα των vptrees, ο παραπάνω κώδικας μπορούσε να γίνει ακόμα ταχύτερος, αν δημιουργούταν ένα δέντροαναζήτησης γειτόνων.Έτσι, αφότου κάθε επεξεργαστής δέχεται τον δικό του υποπίνακα X, καλείται η συνάρτηση vpt_createη οποία δημιουργεί το vptreeπου αντιστοιχεί στα συγκεκριμένα στοιχεία Xκαι είναι ξεχωριστό και σταθερό για κάθε επεξεργαστή. Στη συνέχεια με την ίδια δομή δαχτυλιδιού εναλλάσσονται τα δεδομένα (σημείωση: αυτήν την φορά πέρα από τα δεδομένα πασάρονται και οι πίνακες του knnresult, προκειμένου ναδιατηρείται η πληροφορία των κοντινότερων γειτόνων)και στη συνέχεια γίνεται η ανανέωση των κοντινότερων γειτόνωνμέσω της συνάρτησης search_vptγια το συγκεκριμένο υποσύνολο στοιχείων του, με βάση το vptreeεκείνου του επεξεργαστή (το οποίο είναι σταθερό για κάθε κόμβο). Στο τέλος,κάθε στοιχείο του υποπίνακα θα έχει συγκριθείμε όλα τα vptreesκαι θα έχει κρατήσει τις κοντινότερες αποστάσεις, γλιτώνοντας πολλούς αχρείαστους υπολογισμούς αποστάσεων!

## Διαγράμματα

![alt text](/diagrams/v1/n=20000p=2.jpg "Diagram")